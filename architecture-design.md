# 数学雷电 Phaser.js 架构设计文档

## 1. 项目架构概览

### 核心设计理念
- **模块化设计**: 每个功能独立成模块，便于维护和扩展
- **面向对象**: 使用ES6类继承，清晰的对象关系
- **事件驱动**: 基于Phaser事件系统的松耦合设计
- **性能优化**: 对象池、纹理缓存、智能更新

### 技术栈
- **Phaser 3.90+**: 游戏引擎
- **ES6 模块化**: 现代JavaScript语法
- **Vite 6.3+**: 快速构建工具
- **Arcade Physics**: 物理引擎
- **动态纹理生成**: 无需外部图片资源

## 2. 架构分层

```
┌─────────────────────────────────────┐
│           场景层 (Scenes)            │
│  BootScene → PreloadScene → MenuScene │
│       ↓                             │
│  GameScene ↔ MathQuestionScene      │
│       ↓                             │
│    GameOverScene                    │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│          系统层 (Systems)            │
│  MathSystem | EffectSystem          │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│          对象层 (Objects)            │
│  Player | Enemy | Bullet | Missile  │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│           UI层 (UI)                 │
│            HUD                      │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│          工具层 (Utils)              │
│          Constants                  │
└─────────────────────────────────────┘
```

## 3. 核心设计模式

### 3.1 场景管理模式
- **状态机模式**: 游戏状态通过场景切换管理
- **场景叠加**: 数学题场景叠加在游戏场景之上
- **数据传递**: 场景间通过init方法传递数据

### 3.2 对象池模式
- **子弹管理**: 复用子弹对象，减少GC压力
- **敌机管理**: 动态创建和回收敌机
- **特效管理**: 粒子效果的高效管理

### 3.3 组件化设计
- **玩家组件**: 移动、射击、状态管理分离
- **敌机组件**: AI、移动、射击独立模块
- **UI组件**: HUD、消息、暂停菜单模块化

### 3.4 事件驱动模式
- **碰撞事件**: 物理引擎触发碰撞回调
- **输入事件**: 统一的输入处理系统
- **游戏事件**: 分数变化、状态更新等

## 4. 关键系统设计

### 4.1 数学题系统 (MathSystem)
**设计目标**: 无缝集成数学教育与游戏体验

**核心特性**:
- 三个难度等级的题目生成
- 答题结果的奖励机制
- 游戏暂停/恢复的平滑处理
- 统计和进度跟踪

**设计模式**: 策略模式 + 观察者模式

### 4.2 特效系统 (EffectSystem)
**设计目标**: 丰富的视觉反馈和沉浸感

**核心特性**:
- 粒子系统管理
- 动画和补间效果
- 屏幕震动和视觉冲击
- 性能优化的特效池

**设计模式**: 工厂模式 + 对象池模式

### 4.3 武器系统 (BulletManager)
**设计目标**: 高性能的射击系统

**核心特性**:
- 双向子弹管理（玩家/敌机）
- 多种弹道模式
- 对象池优化
- 碰撞检测集成

**设计模式**: 对象池模式 + 工厂模式

## 5. 性能优化策略

### 5.1 渲染优化
- **动态纹理生成**: 运行时创建简单图形
- **纹理图集**: 减少绘制调用
- **视锥剔除**: 自动清理屏幕外对象

### 5.2 内存优化
- **对象池**: 子弹、特效对象复用
- **智能更新**: 只更新活跃对象
- **资源管理**: 及时释放不用的资源

### 5.3 逻辑优化
- **碰撞检测**: 使用物理引擎的空间分割
- **事件节流**: 避免频繁的事件触发
- **批量处理**: 集中处理相似操作

## 6. 扩展性设计

### 6.1 新敌机类型
- **接口标准化**: 统一的敌机基类
- **配置驱动**: 通过配置文件定义敌机属性
- **AI模块化**: 可插拔的AI行为

### 6.2 新武器类型
- **武器工厂**: 统一的武器创建接口
- **效果组合**: 可组合的武器效果
- **升级路径**: 灵活的武器升级系统

### 6.3 新数学题类型
- **题目生成器**: 可扩展的题目生成接口
- **难度调节**: 动态难度调整机制
- **题型插件**: 支持新题型的插件系统

## 7. 数据流设计

### 7.1 游戏状态流
```
用户输入 → 游戏逻辑 → 状态更新 → UI更新 → 渲染
    ↑                                        ↓
    ←─────────── 事件反馈 ←─────────────────────
```

### 7.2 数学题流程
```
拾取道具 → 暂停游戏 → 显示题目 → 用户答题 → 
应用奖励 → 恢复游戏 → 更新状态 → 继续游戏
```

### 7.3 碰撞处理流
```
物理检测 → 碰撞回调 → 伤害计算 → 状态更新 → 
特效触发 → UI更新 → 音效播放
```

## 8. 配置管理

### 8.1 游戏平衡配置
- **数值配置**: 生命值、伤害、速度等
- **概率配置**: 道具掉落、敌机生成等
- **时间配置**: 射击间隔、无敌时间等

### 8.2 UI配置
- **颜色主题**: 统一的颜色配置
- **字体设置**: 字体大小和样式
- **动画参数**: 动画时长和缓动函数

### 8.3 数学题配置
- **难度设置**: 各等级的数值范围
- **奖励配置**: 答题奖励的类型和数值
- **题型权重**: 不同题型的出现概率

## 9. 错误处理和调试

### 9.1 错误处理策略
- **优雅降级**: 功能失败时的备选方案
- **错误边界**: 防止单个错误影响整个游戏
- **用户友好**: 错误信息的用户友好展示

### 9.2 调试支持
- **开发模式**: 调试信息和性能监控
- **状态检查**: 游戏状态的实时查看
- **事件日志**: 关键事件的记录和回放

## 10. 总结

这个架构设计实现了：

✅ **高内聚低耦合**: 各模块职责清晰，依赖关系简单
✅ **高性能**: 通过对象池、纹理优化等手段保证流畅运行
✅ **高扩展性**: 支持新功能的快速添加和现有功能的修改
✅ **高可维护性**: 模块化设计便于代码维护和团队协作
✅ **用户体验**: 平滑的游戏流程和丰富的视觉反馈

这个设计为数学雷电游戏提供了坚实的技术基础，既满足了当前的功能需求，也为未来的功能扩展留下了充足的空间。 